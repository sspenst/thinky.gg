/* eslint-disable @typescript-eslint/prefer-ts-expect-error, @typescript-eslint/ban-ts-comment */
import fetch, { Headers } from 'node-fetch';
import _http from 'http';
const {
  createServer
} = _http;
import _url from 'url';
const {
  parse: parseUrl
} = _url;
import _cookie from 'cookie';
const {
  parse: parseCookieHeader
} = _cookie;
/**
 * This function is responsible for adding the headers sent along with every
 * fetch request by default. Headers that already exist will not be overwritten.
 *
 * Current default headers:
 *
 * - `x-msw-bypass: true`
 */
const addDefaultHeaders = headers => {
  if (!headers.has('x-msw-bypass')) {
    headers.set('x-msw-bypass', 'true');
  }
  return headers;
};
let apiResolver = null;
// ? The result of this function is memoized by the caller, so this function
// ? will only be invoked the first time this script is imported.
const tryImport = path => e => {
  var _tryImport$importErro;
  (tryImport.importErrors = (_tryImport$importErro = tryImport.importErrors) !== null && _tryImport$importErro !== void 0 ? _tryImport$importErro : []).push(e);
  /* istanbul ignore next */
  if (typeof __webpack_require__ == 'function') {
    return process.env.NODE_ESM ? import( /* webpackIgnore: true */path) : __non_webpack_require__(path);
  } else if (typeof require == 'function') {
    // ? Node12 does not support dynamic imports, so fall back to require first
    return require(path);
  } else {
    return import(path);
  }
};
const handleError = (res, e, deferredReject) => {
  // ? Prevent tests that crash the server from hanging
  !res.writableEnded && res.end();

  // ? Throwing at the point this function was called would not normally cause
  // ? testApiHandler to reject because createServer (an EventEmitter) only
  // ? accepts non-async event handlers which swallow errors from async
  // ? functions (which is why `void` is used instead of `await` below). So
  // ? we'll have to get creative! How about: defer rejections manually?
  /* istanbul ignore else */
  if (deferredReject) deferredReject(e);else throw e;
};

/**
 * The parameters expected by `testApiHandler`.
 */

/**
 * Uses Next's internal `apiResolver` to execute api route handlers in a
 * Next-like testing environment.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export async function testApiHandler({
  rejectOnHandlerError,
  requestPatcher,
  responsePatcher,
  paramsPatcher,
  params,
  url,
  handler,
  test
}) {
  let server = null;
  let deferredReject = null;
  try {
    if (!apiResolver) {
      // ? The following is for next@>=12.1.0:
      // @ts-ignore: conditional import for earlier next versions
      ({
        apiResolver
      } = await import('next/dist/server/api-utils/node.js')
      // ? The following is for next@<12.1.0 >=11.1.0:
      .catch(tryImport('next/dist/server/api-utils.js'))
      // ? The following is for next@<11.1.0 >=9.0.6:
      .catch(tryImport('next/dist/next-server/server/api-utils.js'))
      // ? The following is for next@<9.0.6 >= 9.0.0:
      .catch(tryImport('next-server/dist/server/api-utils.js')).catch(e => (tryImport.importErrors.push(e), {
        apiResolver: null
      })));
      if (!apiResolver) {
        const importErrors = tryImport.importErrors.map(e => e.message.split(/(?<=')( imported)? from ('|\S)/)[0].split(`\nRequire`)[0]).join('\n    - ');
        tryImport.importErrors = [];
        // prettier-ignore
        throw new Error(`next-test-api-route-handler (NTARH) failed to import api-utils.js` + `\n\n  This is usually caused by:` + `\n\n    1. Using npm@<7 and/or node@<15, which doesn't install peer deps automatically (review install instructions)` + `\n    2. NTARH and the version of Next.js you installed are actually incompatible (please submit a bug report)` + `\n\n  Failed import attempts:` + `\n\n    - ${importErrors}`);
      }
    }
    server = createServer((req, res) => {
      try {
        if (typeof apiResolver != 'function') {
          throw new Error('assertion failed unexpectedly: apiResolver was not a function');
        }
        url && (req.url = url);
        requestPatcher && requestPatcher(req);
        responsePatcher && responsePatcher(res);
        const finalParams = {
          ...parseUrl(req.url || '', true).query,
          ...params
        };
        paramsPatcher && paramsPatcher(finalParams);

        /**
         *? From Next.js internals:
         ** apiResolver(
         **    req: IncomingMessage,
         **    res: ServerResponse,
         **    query: any,
         **    resolverModule: any,
         **    apiContext: __ApiPreviewProps,
         **    propagateError: boolean,
         **    ...
         ** )
         */
        void apiResolver(req, res, finalParams, handler,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        undefined, !!rejectOnHandlerError).catch(e => handleError(res, e, deferredReject));
      } catch (e) {
        handleError(res, e, deferredReject);
      }
    });
    const port = await new Promise((resolve, reject) => {
      var _server;
      (_server = server) === null || _server === void 0 ? void 0 : _server.listen(() => {
        var _server2;
        const addr = (_server2 = server) === null || _server2 === void 0 ? void 0 : _server2.address();
        if (!addr || typeof addr == 'string') {
          reject(new Error('assertion failed unexpectedly: server did not return AddressInfo instance'));
        } else {
          resolve(addr.port);
        }
      });
    });
    const localUrl = `http://localhost:${port}`;
    await new Promise((resolve, reject) => {
      deferredReject = reject;
      test({
        fetch: async customInit => {
          const init = {
            ...customInit,
            headers: addDefaultHeaders(new Headers(customInit === null || customInit === void 0 ? void 0 : customInit.headers))
          };
          return fetch(localUrl, init).then(res => {
            // ? Lazy load (on demand) the contents of the `cookies` field
            Object.defineProperty(res, 'cookies', {
              configurable: true,
              enumerable: true,
              get: () => {
                // @ts-expect-error: lazy getter guarantees this will be set
                delete res.cookies;
                res.cookies = [res.headers.raw()['set-cookie'] || []].flat().map(header => Object.entries(parseCookieHeader(header)).reduce((obj, [k, v]) => Object.assign(obj, {
                  [String(k)]: v,
                  [String(k).toLowerCase()]: v
                }), {}));
                return res.cookies;
              }
            });
            return res;
          });
        }
      }).then(resolve, reject);
    });
  } finally {
    var _server3;
    (_server3 = server) === null || _server3 === void 0 ? void 0 : _server3.close();
  }
}