"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testApiHandler = testApiHandler;

var _nodeHttp = require("node:http");

var _nodeUrl = require("node:url");

var _nodeFetch = _interopRequireWildcard(require("node-fetch"));

var _cookie = require("cookie");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const addDefaultHeaders = headers => {
  if (!headers.has('x-msw-bypass')) {
    headers.set('x-msw-bypass', 'true');
  }

  return headers;
};

let apiResolver = null;

const tryImport = path => e => {
  var _tryImport$importErro;

  (tryImport.importErrors = (_tryImport$importErro = tryImport.importErrors) !== null && _tryImport$importErro !== void 0 ? _tryImport$importErro : []).push(e);

  if (typeof __webpack_require__ == 'function') {
    return __non_webpack_require__(path);
  } else if (typeof require == 'function') {
    return require(path);
  } else {
    return Promise.resolve(`${path}`).then(s => _interopRequireWildcard(require(s)));
  }
};

const handleError = (res, e, deferredReject) => {
  !res.writableEnded && res.end();
  if (deferredReject) deferredReject(e);else throw e;
};

async function testApiHandler({
  rejectOnHandlerError,
  requestPatcher,
  responsePatcher,
  paramsPatcher,
  params,
  url,
  handler,
  test
}) {
  let server = null;
  let deferredReject = null;

  try {
    if (!apiResolver) {
      ({
        apiResolver
      } = await Promise.resolve().then(() => _interopRequireWildcard(require('next/dist/server/api-utils/node.js'))).catch(tryImport('next/dist/server/api-utils.js')).catch(tryImport('next/dist/next-server/server/api-utils.js')).catch(tryImport('next-server/dist/server/api-utils.js')).catch(e => (tryImport.importErrors.push(e), {
        apiResolver: null
      })));

      if (!apiResolver) {
        const importErrors = tryImport.importErrors.map(e => e.message.split(/(?<=')( imported)? from ('|\S)/)[0].split(`\nRequire`)[0]).join('\n    - ');
        tryImport.importErrors = [];
        throw new Error(`next-test-api-route-handler (NTARH) failed to import api-utils.js` + `\n\n  This is usually caused by:` + `\n\n    1. Using npm@<7 and/or node@<15, which doesn't install peer deps automatically (review install instructions)` + `\n    2. NTARH and the version of Next.js you installed are actually incompatible (please submit a bug report)` + `\n\n  Failed import attempts:` + `\n\n    - ${importErrors}`);
      }
    }

    server = (0, _nodeHttp.createServer)((req, res) => {
      try {
        if (typeof apiResolver != 'function') {
          throw new Error('assertion failed unexpectedly: apiResolver was not a function');
        }

        url && (req.url = url);
        requestPatcher && requestPatcher(req);
        responsePatcher && responsePatcher(res);
        const finalParams = { ...(0, _nodeUrl.parse)(req.url || '', true).query,
          ...params
        };
        paramsPatcher && paramsPatcher(finalParams);
        void apiResolver(req, res, finalParams, handler, undefined, !!rejectOnHandlerError).catch(e => handleError(res, e, deferredReject));
      } catch (e) {
        handleError(res, e, deferredReject);
      }
    });
    const port = await new Promise((resolve, reject) => {
      var _server;

      (_server = server) === null || _server === void 0 ? void 0 : _server.listen(() => {
        var _server2;

        const addr = (_server2 = server) === null || _server2 === void 0 ? void 0 : _server2.address();

        if (!addr || typeof addr == 'string') {
          reject(new Error('assertion failed unexpectedly: server did not return AddressInfo instance'));
        } else {
          resolve(addr.port);
        }
      });
    });
    const localUrl = `http://localhost:${port}`;
    await new Promise((resolve, reject) => {
      deferredReject = reject;
      test({
        fetch: async customInit => {
          const init = { ...customInit,
            headers: addDefaultHeaders(new _nodeFetch.Headers(customInit === null || customInit === void 0 ? void 0 : customInit.headers))
          };
          return (0, _nodeFetch.default)(localUrl, init).then(res => {
            Object.defineProperty(res, 'cookies', {
              configurable: true,
              enumerable: true,
              get: () => {
                delete res.cookies;
                res.cookies = [res.headers.raw()['set-cookie'] || []].flat().map(header => Object.entries((0, _cookie.parse)(header)).reduce((obj, [k, v]) => Object.assign(obj, {
                  [String(k)]: v,
                  [String(k).toLowerCase()]: v
                }), {}));
                return res.cookies;
              }
            });
            return res;
          });
        }
      }).then(resolve, reject);
    });
  } finally {
    var _server3;

    (_server3 = server) === null || _server3 === void 0 ? void 0 : _server3.close();
  }
}