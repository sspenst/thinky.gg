/// <reference types="node" />
import { parse as parseCookieHeader } from 'cookie';
import type { NextApiHandler } from 'next';
import type { IncomingMessage, ServerResponse } from 'http';
import type { RequestInit, Response as FetchReturnValue } from 'node-fetch';
export type FetchReturnType<NextResponseJsonType> = Promise<Omit<FetchReturnValue, 'json'> & {
    json: (...args: Parameters<FetchReturnValue['json']>) => Promise<NextResponseJsonType>;
    cookies: ReturnType<typeof parseCookieHeader>[];
}>;
/**
 * The parameters expected by `testApiHandler`.
 */
export type NtarhParameters<NextResponseJsonType = unknown> = {
    /**
     * If `false`, errors thrown from within a handler are kicked up to Next.js's
     * resolver to deal with, which is what would happen in production. Instead,
     * if `true`, the {@link testApiHandler} function will reject immediately.
     *
     * @default false
     */
    rejectOnHandlerError?: boolean;
    /**
     * A function that receives an `IncomingMessage` object. Use this function to
     * edit the request before it's injected into the handler.
     *
     * **Note: all replacement `IncomingMessage.header` names must be lowercase.**
     */
    requestPatcher?: (req: IncomingMessage) => void;
    /**
     * A function that receives a `ServerResponse` object. Use this functions to
     * edit the request before it's injected into the handler.
     */
    responsePatcher?: (res: ServerResponse) => void;
    /**
     * A function that receives an object representing "processed" dynamic routes;
     * _modifications_ to this object are passed directly to the handler. This
     * should not be confused with query string parsing, which is handled
     * automatically.
     */
    paramsPatcher?: (params: Record<string, unknown>) => void;
    /**
     * `params` is passed directly to the handler and represent processed dynamic
     * routes. This should not be confused with query string parsing, which is
     * handled automatically.
     *
     * `params: { id: 'some-id' }` is shorthand for `paramsPatcher: (params) =>
     * (params.id = 'some-id')`. This is most useful for quickly setting many
     * params at once.
     */
    params?: Record<string, string | string[]>;
    /**
     * `url: 'your-url'` is shorthand for `requestPatcher: (req) => (req.url =
     * 'your-url')`
     */
    url?: string;
    /**
     * The actual handler under test. It should be an async function that accepts
     * `NextApiRequest` and `NextApiResult` objects (in that order) as its two
     * parameters.
     */
    handler: NextApiHandler<NextResponseJsonType>;
    /**
     * `test` must be a function that runs your test assertions, returning a
     * promise (or async). This function receives one destructured parameter:
     * `fetch`, which is the unfetch package's `fetch(...)` function but with the
     * first parameter omitted.
     */
    test: (params: {
        fetch: (customInit?: RequestInit) => FetchReturnType<NextResponseJsonType>;
    }) => Promise<void>;
};
/**
 * Uses Next's internal `apiResolver` to execute api route handlers in a
 * Next-like testing environment.
 */
export declare function testApiHandler<NextResponseJsonType = any>({ rejectOnHandlerError, requestPatcher, responsePatcher, paramsPatcher, params, url, handler, test }: NtarhParameters<NextResponseJsonType>): Promise<void>;
