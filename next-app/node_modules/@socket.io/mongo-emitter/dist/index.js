"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BroadcastOperator = exports.RESERVED_EVENTS = exports.Emitter = void 0;
const debug_1 = require("debug");
const debug = debug_1.default("socket.io-mongo-emitter");
const EMITTER_UID = "emitter";
/**
 * Event types, for messages between nodes
 */
var EventType;
(function (EventType) {
    EventType[EventType["INITIAL_HEARTBEAT"] = 1] = "INITIAL_HEARTBEAT";
    EventType[EventType["HEARTBEAT"] = 2] = "HEARTBEAT";
    EventType[EventType["BROADCAST"] = 3] = "BROADCAST";
    EventType[EventType["SOCKETS_JOIN"] = 4] = "SOCKETS_JOIN";
    EventType[EventType["SOCKETS_LEAVE"] = 5] = "SOCKETS_LEAVE";
    EventType[EventType["DISCONNECT_SOCKETS"] = 6] = "DISCONNECT_SOCKETS";
    EventType[EventType["FETCH_SOCKETS"] = 7] = "FETCH_SOCKETS";
    EventType[EventType["FETCH_SOCKETS_RESPONSE"] = 8] = "FETCH_SOCKETS_RESPONSE";
    EventType[EventType["SERVER_SIDE_EMIT"] = 9] = "SERVER_SIDE_EMIT";
    EventType[EventType["SERVER_SIDE_EMIT_RESPONSE"] = 10] = "SERVER_SIDE_EMIT_RESPONSE";
})(EventType || (EventType = {}));
class Emitter {
    constructor(mongoCollection, nsp = "/") {
        this.mongoCollection = mongoCollection;
        this.nsp = nsp;
    }
    /**
     * Return a new emitter for the given namespace.
     *
     * @param nsp - namespace
     * @public
     */
    of(nsp) {
        return new Emitter(this.mongoCollection, (nsp[0] !== "/" ? "/" : "") + nsp);
    }
    /**
     * Emits to all clients.
     *
     * @return Always true
     * @public
     */
    emit(ev, ...args) {
        return new BroadcastOperator(this).emit(ev, ...args);
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return BroadcastOperator
     * @public
     */
    to(room) {
        return new BroadcastOperator(this).to(room);
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return BroadcastOperator
     * @public
     */
    in(room) {
        return new BroadcastOperator(this).in(room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @param room
     * @return BroadcastOperator
     * @public
     */
    except(room) {
        return new BroadcastOperator(this).except(room);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because they’re connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @return BroadcastOperator
     * @public
     */
    get volatile() {
        return new BroadcastOperator(this).volatile;
    }
    /**
     * Sets the compress flag.
     *
     * @param compress - if `true`, compresses the sending data
     * @return BroadcastOperator
     * @public
     */
    compress(compress) {
        return new BroadcastOperator(this).compress(compress);
    }
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param rooms
     * @public
     */
    socketsJoin(rooms) {
        return new BroadcastOperator(this).socketsJoin(rooms);
    }
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param rooms
     * @public
     */
    socketsLeave(rooms) {
        return new BroadcastOperator(this).socketsLeave(rooms);
    }
    /**
     * Makes the matching socket instances disconnect
     *
     * @param close - whether to close the underlying connection
     * @public
     */
    disconnectSockets(close = false) {
        return new BroadcastOperator(this).disconnectSockets(close);
    }
    /**
     * Send a packet to the Socket.IO servers in the cluster
     *
     * @param args - any number of serializable arguments
     */
    serverSideEmit(ev, ...args) {
        const withAck = args.length && typeof args[args.length - 1] === "function";
        if (withAck) {
            throw new Error("Acknowledgements are not supported");
        }
        this.mongoCollection.insertOne({
            uid: EMITTER_UID,
            nsp: this.nsp,
            type: EventType.SERVER_SIDE_EMIT,
            data: {
                packet: [ev, ...args],
            },
        });
    }
}
exports.Emitter = Emitter;
exports.RESERVED_EVENTS = new Set([
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener",
]);
class BroadcastOperator {
    constructor(emitter, rooms = new Set(), exceptRooms = new Set(), flags = {}) {
        this.emitter = emitter;
        this.rooms = rooms;
        this.exceptRooms = exceptRooms;
        this.flags = flags;
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return a new BroadcastOperator instance
     * @public
     */
    to(room) {
        const rooms = new Set(this.rooms);
        if (Array.isArray(room)) {
            room.forEach((r) => rooms.add(r));
        }
        else {
            rooms.add(room);
        }
        return new BroadcastOperator(this.emitter, rooms, this.exceptRooms, this.flags);
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return a new BroadcastOperator instance
     * @public
     */
    in(room) {
        return this.to(room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @param room
     * @return a new BroadcastOperator instance
     * @public
     */
    except(room) {
        const exceptRooms = new Set(this.exceptRooms);
        if (Array.isArray(room)) {
            room.forEach((r) => exceptRooms.add(r));
        }
        else {
            exceptRooms.add(room);
        }
        return new BroadcastOperator(this.emitter, this.rooms, exceptRooms, this.flags);
    }
    /**
     * Sets the compress flag.
     *
     * @param compress - if `true`, compresses the sending data
     * @return a new BroadcastOperator instance
     * @public
     */
    compress(compress) {
        const flags = Object.assign({}, this.flags, { compress });
        return new BroadcastOperator(this.emitter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because they’re connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @return a new BroadcastOperator instance
     * @public
     */
    get volatile() {
        const flags = Object.assign({}, this.flags, { volatile: true });
        return new BroadcastOperator(this.emitter, this.rooms, this.exceptRooms, flags);
    }
    publish(document) {
        document.uid = EMITTER_UID;
        document.nsp = this.emitter.nsp;
        debug("publishing %j", document);
        this.emitter.mongoCollection.insertOne(document);
    }
    /**
     * Emits to all clients.
     *
     * @return Always true
     * @public
     */
    emit(ev, ...args) {
        if (exports.RESERVED_EVENTS.has(ev)) {
            throw new Error(`"${ev}" is a reserved event name`);
        }
        // set up packet object
        const data = [ev, ...args];
        const packet = {
            type: 2,
            data: data,
            nsp: this.emitter.nsp,
        };
        const opts = {
            rooms: [...this.rooms],
            flags: this.flags,
            except: [...this.exceptRooms],
        };
        this.publish({
            type: EventType.BROADCAST,
            data: {
                packet,
                opts,
            },
        });
        return true;
    }
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param rooms
     * @public
     */
    socketsJoin(rooms) {
        this.publish({
            type: EventType.SOCKETS_JOIN,
            data: {
                opts: {
                    rooms: [...this.rooms],
                    except: [...this.exceptRooms],
                },
                rooms: Array.isArray(rooms) ? rooms : [rooms],
            },
        });
    }
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param rooms
     * @public
     */
    socketsLeave(rooms) {
        this.publish({
            type: EventType.SOCKETS_LEAVE,
            data: {
                opts: {
                    rooms: [...this.rooms],
                    except: [...this.exceptRooms],
                },
                rooms: Array.isArray(rooms) ? rooms : [rooms],
            },
        });
    }
    /**
     * Makes the matching socket instances disconnect
     *
     * @param close - whether to close the underlying connection
     * @public
     */
    disconnectSockets(close = false) {
        this.publish({
            type: EventType.DISCONNECT_SOCKETS,
            data: {
                opts: {
                    rooms: [...this.rooms],
                    except: [...this.exceptRooms],
                },
                close,
            },
        });
    }
}
exports.BroadcastOperator = BroadcastOperator;
