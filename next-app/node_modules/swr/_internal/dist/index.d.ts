import react, { FC, PropsWithChildren, MutableRefObject } from 'react';

declare const FOCUS_EVENT = 0;
declare const RECONNECT_EVENT = 1;
declare const MUTATE_EVENT = 2;

declare const constants_FOCUS_EVENT: typeof FOCUS_EVENT;
declare const constants_RECONNECT_EVENT: typeof RECONNECT_EVENT;
declare const constants_MUTATE_EVENT: typeof MUTATE_EVENT;
declare namespace constants {
  export {
    constants_FOCUS_EVENT as FOCUS_EVENT,
    constants_RECONNECT_EVENT as RECONNECT_EVENT,
    constants_MUTATE_EVENT as MUTATE_EVENT,
  };
}

declare const compare: (currentData: any, newData: any) => boolean;
declare const cache: Cache<any>;
declare const mutate: ScopedMutator<any>;

declare const defaultConfig: FullConfiguration;

declare type GlobalState = [
    Record<string, RevalidateCallback[]>,
    Record<string, [number, number]>,
    Record<string, [any, number]>,
    Record<string, FetcherResponse<any>>,
    ScopedMutator,
    (key: string, value: any, prev: any) => void,
    (key: string, callback: (current: any, prev: any) => void) => () => void
];
declare type FetcherResponse<Data = unknown> = Data | Promise<Data>;
declare type BareFetcher<Data = unknown> = (...args: any[]) => FetcherResponse<Data>;
declare type Fetcher<Data = unknown, SWRKey extends Key = Key> = SWRKey extends () => infer Arg | null | undefined | false ? (args: Arg) => FetcherResponse<Data> : SWRKey extends null | undefined | false ? never : SWRKey extends infer Arg ? (args: Arg) => FetcherResponse<Data> : never;
interface InternalConfiguration {
    cache: Cache;
    mutate: ScopedMutator;
}
/**
 * @link https://swr.vercel.app/docs/options
 */
interface PublicConfiguration<Data = any, Error = any, Fn extends Fetcher = BareFetcher> {
    /**
     *  error retry interval in milliseconds
     *  @defaultValue 5000
     */
    errorRetryInterval: number;
    /** max error retry count */
    errorRetryCount?: number;
    /**
     * timeout to trigger the onLoadingSlow event in milliseconds
     * @defaultValue 3000
     */
    loadingTimeout: number;
    /**
     * only revalidate once during a time span in milliseconds
     * @defaultValue 5000
     */
    focusThrottleInterval: number;
    /**
     * dedupe requests with the same key in this time span in milliseconds
     * @defaultValue 2000
     */
    dedupingInterval: number;
    /**
     *  @link https://swr.vercel.app/docs/revalidation
     *  * Disabled by default: `refreshInterval = 0`
     *  * If set to a number, polling interval in milliseconds
     *  * If set to a function, the function will receive the latest data and should return the interval in milliseconds
     */
    refreshInterval?: number | ((latestData: Data | undefined) => number);
    /**
     * polling when the window is invisible (if `refreshInterval` is enabled)
     * @defaultValue false
     *
     */
    refreshWhenHidden?: boolean;
    /**
     * polling when the browser is offline (determined by `navigator.onLine`)
     */
    refreshWhenOffline?: boolean;
    /**
     * automatically revalidate when window gets focused
     * @defaultValue true
     * @link https://swr.vercel.app/docs/revalidation
     */
    revalidateOnFocus: boolean;
    /**
     * automatically revalidate when the browser regains a network connection (via `navigator.onLine`)
     * @defaultValue true
     * @link https://swr.vercel.app/docs/revalidation
     */
    revalidateOnReconnect: boolean;
    /**
     * enable or disable automatic revalidation when component is mounted
     */
    revalidateOnMount?: boolean;
    /**
     * automatically revalidate even if there is stale data
     * @defaultValue true
     * @link https://swr.vercel.app/docs/revalidation#disable-automatic-revalidations
     */
    revalidateIfStale: boolean;
    /**
     * retry when fetcher has an error
     * @defaultValue true
     */
    shouldRetryOnError: boolean | ((err: Error) => boolean);
    /**
     * keep the previous result when key is changed but data is not ready
     * @defaultValue false
     */
    keepPreviousData?: boolean;
    /**
     * @experimental  enable React Suspense mode
     * @defaultValue false
     * @link https://swr.vercel.app/docs/suspense
     */
    suspense?: boolean;
    /**
     * initial data to be returned (note: ***This is per-hook***)
     */
    fallbackData?: Data;
    /**
     * the fetcher function
     */
    fetcher?: Fn;
    /**
     * array of middleware functions
     * @link https://swr.vercel.app/docs/middleware
     */
    use?: Middleware[];
    /**
     * a key-value object of multiple fallback data
     * @link https://swr.vercel.app/docs/with-nextjs#pre-rendering-with-default-data
     */
    fallback: {
        [key: string]: any;
    };
    /**
     * function to detect whether pause revalidations, will ignore fetched data and errors when it returns true. Returns false by default.
     */
    isPaused: () => boolean;
    /**
     * callback function when a request takes too long to load (see `loadingTimeout`)
     */
    onLoadingSlow: (key: string, config: Readonly<PublicConfiguration<Data, Error, Fn>>) => void;
    /**
     * callback function when a request finishes successfully
     */
    onSuccess: (data: Data, key: string, config: Readonly<PublicConfiguration<Data, Error, Fn>>) => void;
    /**
     * callback function when a request returns an error
     */
    onError: (err: Error, key: string, config: Readonly<PublicConfiguration<Data, Error, Fn>>) => void;
    /**
     * handler for error retry
     */
    onErrorRetry: (err: Error, key: string, config: Readonly<PublicConfiguration<Data, Error, Fn>>, revalidate: Revalidator, revalidateOpts: Required<RevalidatorOptions>) => void;
    /**
     * callback function when a request is ignored
     */
    onDiscarded: (key: string) => void;
    /**
     * comparison function used to detect when returned data has changed, to avoid spurious rerenders. By default, [stable-hash](https://github.com/shuding/stable-hash) is used.
     */
    compare: (a: Data | undefined, b: Data | undefined) => boolean;
    /**
     * isOnline and isVisible are functions that return a boolean, to determine if the application is "active". By default, SWR will bail out a revalidation if these conditions are not met.
     * @link https://swr.vercel.app/docs/advanced/react-native#customize-focus-and-reconnect-events
     */
    isOnline: () => boolean;
    /**
     * isOnline and isVisible are functions that return a boolean, to determine if the application is "active". By default, SWR will bail out a revalidation if these conditions are not met.
     * @link https://swr.vercel.app/docs/advanced/react-native#customize-focus-and-reconnect-events
     */
    isVisible: () => boolean;
}
declare type FullConfiguration = InternalConfiguration & PublicConfiguration;
declare type ProviderConfiguration = {
    initFocus: (callback: () => void) => (() => void) | void;
    initReconnect: (callback: () => void) => (() => void) | void;
};
/**
 * @example
 * ```ts
 * const { data, error } = useSWR(key, fetcher)
 * ```
 */
interface SWRHook {
    <Data = any, Error = any, SWRKey extends Key = null>(key: SWRKey): SWRResponse<Data, Error>;
    <Data = any, Error = any, SWRKey extends Key = null>(key: SWRKey, fetcher: Fetcher<Data, SWRKey> | null): SWRResponse<Data, Error>;
    <Data = any, Error = any, SWRKey extends Key = null>(key: SWRKey, config: SWRConfiguration<Data, Error, Fetcher<Data, SWRKey>> | undefined): SWRResponse<Data, Error>;
    <Data = any, Error = any, SWRKey extends Key = null>(key: SWRKey, fetcher: Fetcher<Data, SWRKey> | null, config: SWRConfiguration<Data, Error, Fetcher<Data, SWRKey>> | undefined): SWRResponse<Data, Error>;
    <Data = any, Error = any>(key: Key): SWRResponse<Data, Error>;
    <Data = any, Error = any>(key: Key, fetcher: BareFetcher<Data> | null): SWRResponse<Data, Error>;
    <Data = any, Error = any>(key: Key, config: SWRConfiguration<Data, Error, BareFetcher<Data>> | undefined): SWRResponse<Data, Error>;
    <Data = any, Error = any>(key: Key, fetcher: BareFetcher<Data> | null, config: SWRConfiguration<Data, Error, BareFetcher<Data>> | undefined): SWRResponse<Data, Error>;
}
declare type Middleware = (useSWRNext: SWRHook) => <Data = any, Error = any>(key: Key, fetcher: BareFetcher<Data> | null, config: typeof defaultConfig & SWRConfiguration<Data, Error, BareFetcher<Data>>) => SWRResponse<Data, Error>;
declare type ArgumentsTuple = [any, ...unknown[]] | readonly [any, ...unknown[]];
declare type Arguments = string | ArgumentsTuple | Record<any, any> | null | undefined | false;
declare type Key = Arguments | (() => Arguments);
declare type MutatorCallback<Data = any> = (currentData?: Data) => Promise<undefined | Data> | undefined | Data;
declare type MutatorOptions<Data = any> = {
    revalidate?: boolean;
    populateCache?: boolean | ((result: any, currentData: Data | undefined) => Data);
    optimisticData?: Data | ((currentData?: Data) => Data);
    rollbackOnError?: boolean | ((error: unknown) => boolean);
    throwOnError?: boolean;
};
declare type MutatorConfig = {
    revalidate?: boolean;
    populateCache?: boolean;
};
declare type Broadcaster<Data = any, Error = any> = (cache: Cache<Data>, key: string, data: Data, error?: Error, isValidating?: boolean, revalidate?: boolean, populateCache?: boolean) => Promise<Data>;
declare type State<Data = any, Error = any> = {
    data?: Data;
    error?: Error;
    isValidating?: boolean;
    isLoading?: boolean;
};
declare type MutatorFn<Data = any> = (cache: Cache, key: Key, data?: Data | Promise<Data> | MutatorCallback<Data>, opts?: boolean | MutatorOptions<Data>) => Promise<Data | undefined>;
declare type MutatorWrapper<Fn> = Fn extends (...args: [...infer Parameters]) => infer Result ? Parameters[3] extends boolean ? Result : Parameters[3] extends Required<Pick<MutatorOptions, 'populateCache'>> ? Parameters[3]['populateCache'] extends false ? never : Result : Result : never;
declare type Mutator<Data = any> = MutatorWrapper<MutatorFn<Data>>;
interface ScopedMutator<Data = any> {
    <T = Data>(matcher: (key?: Arguments) => boolean, data?: T | Promise<T> | MutatorCallback<T>, opts?: boolean | MutatorOptions<Data>): Promise<Array<T | undefined>>;
    <T = Data>(key: Arguments, data?: T | Promise<T> | MutatorCallback<T>, opts?: boolean | MutatorOptions<Data>): Promise<T | undefined>;
}
declare type KeyedMutator<Data> = (data?: Data | Promise<Data> | MutatorCallback<Data>, opts?: boolean | MutatorOptions<Data>) => Promise<Data | undefined>;
declare type SWRConfiguration<Data = any, Error = any, Fn extends BareFetcher<any> = BareFetcher<any>> = Partial<PublicConfiguration<Data, Error, Fn>>;
interface SWRResponse<Data = any, Error = any> {
    /**
     * The returned data of the fetcher function.
     */
    data: Data | undefined;
    /**
     * The error object thrown by the fetcher function.
     */
    error: Error | undefined;
    mutate: KeyedMutator<Data>;
    isValidating: boolean;
    isLoading: boolean;
}
declare type KeyLoader<Args extends Arguments = Arguments> = ((index: number, previousPageData: any | null) => Args) | null;
interface RevalidatorOptions {
    retryCount?: number;
    dedupe?: boolean;
}
declare type Revalidator = (revalidateOpts?: RevalidatorOptions) => Promise<boolean> | void;
declare type RevalidateEvent = typeof FOCUS_EVENT | typeof RECONNECT_EVENT | typeof MUTATE_EVENT;
declare type RevalidateCallbackReturnType = {
    [FOCUS_EVENT]: void;
    [RECONNECT_EVENT]: void;
    [MUTATE_EVENT]: Promise<boolean>;
};
declare type RevalidateCallback = <K extends RevalidateEvent>(type: K) => RevalidateCallbackReturnType[K];
interface Cache<Data = any> {
    keys(): IterableIterator<string>;
    get(key: Key): State<Data> | undefined;
    set(key: Key, value: State<Data>): void;
    delete(key: Key): void;
}
interface StateDependencies {
    data?: boolean;
    error?: boolean;
    isValidating?: boolean;
    isLoading?: boolean;
}

declare type Config = SWRConfiguration & Partial<ProviderConfiguration> & {
    provider?: (cache: Readonly<Cache>) => Cache;
};
declare const SWRConfig: FC<PropsWithChildren<{
    value?: Config | ((parentConfig?: Config) => Config);
}>>;

declare const initCache: <Data = any>(provider: Cache<Data>, options?: Partial<ProviderConfiguration>) => [Cache<Data>, ScopedMutator<Data>, () => void, () => void] | [Cache<Data>, ScopedMutator<Data>] | undefined;

declare const IS_REACT_LEGACY = false;
declare const IS_SERVER: boolean;
declare const rAF: (f: (...args: any[]) => void) => number | ReturnType<typeof setTimeout>;
declare const useIsomorphicLayoutEffect: typeof react.useEffect;
declare const slowConnection: boolean | undefined;

declare const SWRGlobalState: WeakMap<Cache<any>, GlobalState>;

declare const stableHash: (arg: any) => string;

declare const noop: () => void;
declare const UNDEFINED: undefined;
declare const OBJECT: ObjectConstructor;
declare const isUndefined: (v: any) => v is undefined;
declare const isFunction: <T extends (...args: any[]) => any = (...args: any[]) => any>(v: unknown) => v is T;
declare const mergeObjects: (a: any, b?: any) => any;
declare const isWindowDefined: boolean;
declare const isDocumentDefined: boolean;
declare const hasRequestAnimationFrame: () => boolean;
declare const createCacheHelper: <Data = any, T = State<Data, any>>(cache: Cache, key: Key) => readonly [() => T, (info: T) => void, (key: string, callback: (current: any, prev: any) => void) => () => void];

declare const mergeConfigs: (a: Partial<FullConfiguration>, b?: Partial<FullConfiguration>) => Partial<FullConfiguration>;

declare type KeyFilter = (key?: Arguments) => boolean;
declare function internalMutate<Data>(cache: Cache, _key: KeyFilter, _data?: Data | Promise<Data | undefined> | MutatorCallback<Data>, _opts?: boolean | MutatorOptions<Data>): Promise<Array<Data | undefined>>;
declare function internalMutate<Data>(cache: Cache, _key: Arguments, _data?: Data | Promise<Data | undefined> | MutatorCallback<Data>, _opts?: boolean | MutatorOptions<Data>): Promise<Data | undefined>;

declare const normalize: <KeyType_1 = Key, Data = any>(args: [KeyType_1] | [KeyType_1, ((args: string) => FetcherResponse<Data>) | ((args: [any, ...unknown[]]) => FetcherResponse<Data>) | ((args: readonly [any, ...unknown[]]) => FetcherResponse<Data>) | ((args: Record<any, any>) => FetcherResponse<Data>) | ((args: string | [any, ...unknown[]] | readonly [any, ...unknown[]] | Record<any, any>) => FetcherResponse<Data>) | null] | [KeyType_1, Partial<PublicConfiguration<any, any, BareFetcher<any>>> | undefined] | [KeyType_1, ((args: string) => FetcherResponse<Data>) | ((args: [any, ...unknown[]]) => FetcherResponse<Data>) | ((args: readonly [any, ...unknown[]]) => FetcherResponse<Data>) | ((args: Record<any, any>) => FetcherResponse<Data>) | ((args: string | [any, ...unknown[]] | readonly [any, ...unknown[]] | Record<any, any>) => FetcherResponse<Data>) | null, Partial<PublicConfiguration<any, any, BareFetcher<any>>> | undefined]) => [KeyType_1, ((args: string) => FetcherResponse<Data>) | ((args: [any, ...unknown[]]) => FetcherResponse<Data>) | ((args: readonly [any, ...unknown[]]) => FetcherResponse<Data>) | ((args: Record<any, any>) => FetcherResponse<Data>) | ((args: string | [any, ...unknown[]] | readonly [any, ...unknown[]] | Record<any, any>) => FetcherResponse<Data>) | null, Partial<Partial<PublicConfiguration<Data, any, BareFetcher<any>>>>];

declare const withArgs: <SWRType>(hook: any) => SWRType;

declare const serialize: (key: Key) => [string, Key];

/**
 * An implementation of state with dependency-tracking.
 */
declare const useStateWithDeps: <S = any>(state: any) => [MutableRefObject<any>, Record<keyof S, boolean>, (payload: Partial<S>) => void];

declare type Callback = (...args: any[]) => any;
declare const subscribeCallback: (key: string, callbacks: Record<string, Callback[]>, callback: Callback) => () => void;

declare const getTimestamp: () => number;

declare const useSWRConfig: () => FullConfiguration;

declare const preset: {
    readonly isOnline: () => boolean;
    readonly isVisible: () => boolean;
};
declare const defaultConfigOptions: ProviderConfiguration;

declare const withMiddleware: (useSWR: SWRHook, middleware: Middleware) => SWRHook;

declare const preload: <Data = any>(key_: Key, fetcher: BareFetcher<Data>) => any;

export { Arguments, BareFetcher, Broadcaster, Cache, Fetcher, FetcherResponse, FullConfiguration, GlobalState, IS_REACT_LEGACY, IS_SERVER, InternalConfiguration, Key, KeyLoader, KeyedMutator, Middleware, Mutator, MutatorCallback, MutatorConfig, MutatorFn, MutatorOptions, MutatorWrapper, OBJECT, ProviderConfiguration, PublicConfiguration, RevalidateCallback, RevalidateEvent, Revalidator, RevalidatorOptions, SWRConfig, SWRConfiguration, SWRGlobalState, SWRHook, SWRResponse, ScopedMutator, State, StateDependencies, UNDEFINED, cache, compare, createCacheHelper, defaultConfig, defaultConfigOptions, getTimestamp, hasRequestAnimationFrame, initCache, internalMutate, isDocumentDefined, isFunction, isUndefined, isWindowDefined, mergeConfigs, mergeObjects, mutate, noop, normalize, preload, preset, rAF, constants as revalidateEvents, serialize, slowConnection, stableHash, subscribeCallback, useIsomorphicLayoutEffect, useSWRConfig, useStateWithDeps, withArgs, withMiddleware };
